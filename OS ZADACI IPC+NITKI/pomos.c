// 1. Прво основната структура
int main(int argc, char *argv[]) {
    if (argc < 2) return -1;
    // тука ќе додадам код
    return 0;
}

// 2. Додавам споделена меморија
int shm_id = shmget(IPC_PRIVATE, SHM_SIZE, IPC_CREAT | 0666);
float *shared_memory = (float *)shmat(shm_id, NULL, 0);

// 3. Додавам циклус за датотеките
for (int i = 1; i < argc; i++) {
    // тука ќе креирам процеси
}

// 4. Додавам fork()
pid_t pid = fork();
if (pid == 0) {
    // код за дете
} else {
    // код за родител
}

// 5. Додавам читање на датотека
int fd = open(argv[i], O_RDONLY);
char buffer[100];
while (read(fd, buffer, 100) > 0) {
    // обработка
}


- Треба да читам повеќе датотеки -> значи ќе ми треба циклус
- Треба да читам по 100 бајти -> значи ми треба баф од 100
- Треба да бројам букви -> значи ми треба функција за броење
- Треба да чувам просеци -> значи ми треба споделена меморија


- Ако читам повеќе датотеки, дали да ги читам:
  а) секвенцијално (една по една)
  б) паралелно (со процеси)
- Во овој случај, паралелно е подобро -> значи ќе ми треба fork()

- Што треба да споделам? -> просеците од секоја датотека
- Колку простор ми треба? -> барем број_на_датотеки * sizeof(float)
- Кој ќе пишува, кој ќе чита? -> децата пишуваат, родителот чита


- Како да читам по 100 бајти? -> со read() во циклус
- Што да правам со секои 100 бајти? -> да бројам букви
- Како да го чувам резултатот? -> во споделената меморија

- Што сè сум отворила? -> датотеки, споделена меморија
- Што треба да затворам? -> close(), shmdt(), shmctl()


































НАЈВАЖЕН ЧЕК - Анализа на задачата:

CopyПрашајте се:
- Дали имам независни работи што можат да се работат паралелно?
- Дали треба да споделувам податоци помеѓу паралелните делови?
- Дали податоците треба да се менуваат или само да се читаат?

ИЗБОР НА ПРИСТАП:

CopyА) Кога да користам ПРОЦЕСИ (fork):
   - Кога работите се независни
   - Кога треба да извршувам различни програми (exec)
   - Кога сакам поголема сигурност (процесите се изолирани)

Б) Кога да користам НИШКИ (pthread):
   - Кога делат иста меморија
   - Кога често комуницираат меѓу себе
   - Кога работат со исти податоци

ИЗБОР НА СПОДЕЛУВАЊЕ НА ПОДАТОЦИ:

CopyА) СПОДЕЛЕНА МЕМОРИЈА (shmget/shmat):
   - Кога имам процеси
   - Кога податоците се менуваат
   - Помалку податоци (неколку променливи)

Б) МАПИРАНА МЕМОРИЈА (mmap):
   - Кога работам со датотеки
   - Кога имам многу податоци
   - Кога повеќе се чита отколку што се пишува

ШАБЛОНИ ЗА РЕШАВАЊЕ:

cCopy// ШАБЛОН 1: Родител-Деца со споделена меморија
int shm_id = shmget(IPC_PRIVATE, size, IPC_CREAT | 0666);
int *shared = shmat(shm_id, NULL, 0);

for(int i = 0; i < N; i++) {
    if(fork() == 0) {
        // Дете работи нешто
        shared[i] = result;
        exit(0);
    }
}
// Родител чека и собира резултати
for(int i = 0; i < N; i++) wait(NULL);




cCopy// ШАБЛОН 2: Нишки со заедничка структура
typedef struct {
    int *data;
    int index;
} ThreadData;

void *thread_function(void *arg) {
    ThreadData *data = (ThreadData *)arg;
    // Работи нешто
    return NULL;
}

int main() {
    pthread_t threads[N];
    ThreadData data[N];
    
    for(int i = 0; i < N; i++) {
        data[i].index = i;
        pthread_create(&threads[i], NULL, thread_function, &data[i]);
    }
    
    for(int i = 0; i < N; i++) 
        pthread_join(threads[i], NULL);
}



cCopy// ШАБЛОН 3: Мапирана датотека со процеси
int fd = open(filename, O_RDONLY);
int size = lseek(fd, 0, SEEK_END);
char *file = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);

for(int i = 0; i < N; i++) {
    if(fork() == 0) {
        // Работи со file[start] до file[end]
        exit(0);
    }
}

КЛУЧНИ РАБОТИ ЗА ПАМТЕЊЕ:

Copy- Секогаш затворај ги ресурсите (close, munmap, shmdt)
- Секогаш чекај ги процесите/нишките да завршат
- Внимавај на race conditions кај споделени податоци
- Провери дали функциите успеале (if == -1)

ЧЕСТИ ГРЕШКИ ЗА ИЗБЕГНУВАЊЕ:

Copy- Не заборавај exit() во дете процесите
- Не заборавај wait() во родителот
- Не споделувај локални променливи меѓу процеси
- Не користи premature optimization

ПРОЦЕС НА РЕШАВАЊЕ:

Copy1. Нацртај дијаграм на хартија
2. Напиши го скелетот на програмата
3. Додавај функционалност постепено
4. Тестирај после секој чекор