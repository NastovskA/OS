/*1.Да се напише програма во С програмскиот јазик за pipeline извршување на процеси. На почеток,
програмата дозволува внесување на вредност Х од тастатура, притоа треба да се креираат Х процеси кои
што ќе комуницираат преку pipeline (Х не повеќе од 10). Наредбите се без аргументи и се внесуваат од
тастатура, така што, првата внесена наредба од тастатура е првиот процес, втората наредба е вториот
процес и т.н. Секој нареден процес, комуницира со следниот преку pipeline, така што чита од
претходниот процес, печати во следниот процес (првиот процес – наредба чита од тастатура, додека
последниот процес печати на екран).
2.Бонус: Да се внесе во првиот процес дополнителна вредност Y која, доколку има вредност 0, тогаш
pipeline е стандарден, но, доколку Y е различно од 0, тогаш секоја наредба од pipeline-от, исто така да
печати и на екран и во десниот pipeline (слично на shell наредбата tee).
Пример:
./zadaca
3
ls
cat
wc
Резултатот треба да ја реализира следнава shell наредба: ls | cat | w*/
#include <sys/types.h>      // За типот pid_t
#include <stdio.h>          // За printf и scanf
#include <unistd.h>         // За fork, pipe, dup2, execlp

int main(int argc, char *argv[]) {
    pid_t dete;             // PID за секој дете-процес
    int X, i;               // X е бројот на процеси, i е бројач
    int p[10][2];           // Маса за максимум 10 pipe-ови (секој има читање и запишување)
    char n[10][30];         // Маса за максимум 10 наредби (секоја со најмногу 30 букви)

    printf("Vnesi go X: ");     // Побарај од корисникот број на процеси
    scanf("%d", &X);            // Сними го тој број во X

    for(i = 0; i < X; i++) {
        printf("Vnesi naredba %d: ", i + 1); // Побарај наредба за секој процес
        scanf("%s", n[i]);                  // Сними ја наредбата во n[i]
    }

    for(i = 0; i < X - 1; i++) {
        pipe(p[i]);         // Креирај pipe p[i]
        //ito znaci btojot na pipe-ot
        dete = fork();      // Направи дете-процес

        if(dete > 0)        // Ако сме родител (враќа PID > 0)
            break;          // Прекини го циклусот – родителот излегува
        // Детето продолжува и создава следен процес
    }

    if(i != 0) {
        close(p[i - 1][1]);             // Ако не сме првиот процес, затвори го делот за запишување на претходниот pipe
        dup2(p[i - 1][0], 0);           // Поврзи го стандардниот влез со читање од претходниот pipe
    }
//1-pisuvanje
//0-citanje
    if(i != X - 1) {
        close(p[i][0]);                 // Ако не сме последниот процес, затвори го делот за читање на тековниот pipe
        dup2(p[i][1], 1);               // Поврзи го стандардниот излез со запишување во следниот pipe
    }

    execlp(n[i], n[i], NULL);           // Изврши ја наредбата n[i] (заменува го процесот со таа команда)

    printf("neuspeshno izvrshuvanje na naredba %s\n", n[i]); // Ако execlp не успее
    return 0; // Заврши ја програмата
}